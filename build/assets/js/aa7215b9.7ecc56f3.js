"use strict";(self.webpackChunkmantis_docs=self.webpackChunkmantis_docs||[]).push([[447],{4910:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=t(4848),i=t(8453);const o={sidebar_position:2},r="Solvers",a={id:"protocol/solvers",title:"Solvers",description:"The solver role is critical to Mantis and the chain-agnostic execution of user intents. To summarize the role, a solver:",source:"@site/docs/protocol/solvers.md",sourceDirName:"protocol",slug:"/protocol/solvers",permalink:"/protocol/solvers",draft:!1,unlisted:!1,editUrl:"https://github.com/ComposableFi/mantis-docs/docs/protocol/solvers.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"protocol",previous:{title:"The Mantis Protocol",permalink:"/protocol/mantis"},next:{title:"Ecosystem",permalink:"/protocol/ecosystem"}},l={},c=[{value:"How Solving on Mantis Works",id:"how-solving-on-mantis-works",level:2},{value:"Solver Interfaces and Mempool",id:"solver-interfaces-and-mempool",level:3},{value:"Types of Orders, Venues, and Solutions",id:"types-of-orders-venues-and-solutions",level:3},{value:"Syntax",id:"syntax",level:2},{value:"Data Structures",id:"data-structures",level:3},{value:"SwapTransferInput",id:"swaptransferinput",level:4},{value:"SwapTransferOutput",id:"swaptransferoutput",level:4},{value:"LendInput and LendOutput",id:"lendinput-and-lendoutput",level:4},{value:"BorrowInput and BorrowOutput",id:"borrowinput-and-borrowoutput",level:4},{value:"Enums",id:"enums",level:3},{value:"OperationInput",id:"operationinput",level:4},{value:"OperationOutput",id:"operationoutput",level:4},{value:"IntentInfo",id:"intentinfo",level:3},{value:"Summary Diagram",id:"summary-diagram",level:3},{value:"Solver Algorithm\u200b",id:"solver-algorithm",level:2},{value:"Fast Withdrawals",id:"fast-withdrawals",level:3},{value:"Scoring",id:"scoring",level:2},{value:"Conditional Intents",id:"conditional-intents",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"solvers",children:"Solvers"})}),"\n",(0,s.jsx)(n.p,{children:"The solver role is critical to Mantis and the chain-agnostic execution of user intents. To summarize the role, a solver:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Takes in data about users\u2019 intents"}),"\n",(0,s.jsx)(n.li,{children:"Comes up with a solution to fulfill these intents as transactions"}),"\n",(0,s.jsx)(n.li,{children:"Is incentivized to perform this role"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you are interested in solving for Mantis or simply want to learn more about how Mantis solvers work, refer to the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/ComposableFi/composable/blob/main/docs/docs/technology/mantis/tutorial.md",children:"Discovering Mantis Orders"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/ComposableFi/composable/blob/main/docs/docs/technology/mantis/solver-tutorial.md",children:"Solving for Mantis"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/ComposableFi/composable/blob/main/docs/docs/technology/mantis/problem-solver-flow.md",children:"Solver Integration"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"how-solving-on-mantis-works",children:"How Solving on Mantis Works"}),"\n",(0,s.jsx)(n.p,{children:"On Mantis, solvers compete to deliver best execution for intents. The process for this is as follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Solvers must first be onboarded onto the Mantis network."}),"\n",(0,s.jsx)(n.li,{children:"The solver obtains data on intents, which is stored in the problem mempool."}),"\n",(0,s.jsx)(n.li,{children:"The solver uses an optimization algorithm to determine a solution route to settle the user intent at the best price."}),"\n",(0,s.jsx)(n.li,{children:"Solvers send their proposed solution routes to the auctioneer."}),"\n",(0,s.jsx)(n.li,{children:"The auctioneer scores proposed solutions. The winning solution is that which best suits the user\u2019s intent and desired parameters."}),"\n",(0,s.jsx)(n.li,{children:"The winning solver must execute the proposed solution for the user intent."}),"\n",(0,s.jsxs)(n.li,{children:["If the winning solver executes the path as specified, they are rewarded, If they do not, they are slashed. Initially, slashing will be permissioned and off-chain. ",(0,s.jsx)(n.a,{href:"https://pyth.network/",children:"Pyth Network"}),"\u2019s data streams will be used to measure the difference between how a solver executes a transaction against their proposed solution. Based on this, solver performance will be publicly displayed."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solver-interfaces-and-mempool",children:"Solver Interfaces and Mempool"}),"\n",(0,s.jsx)(n.p,{children:"The initial Mantis implementation will have solvers directly tap into the sequencer to query the problem mempool. In the future, we will introduce other privacy mechanisms on our rollup to prevent intent and solution data leakage."}),"\n",(0,s.jsx)(n.h3,{id:"types-of-orders-venues-and-solutions",children:"Types of Orders, Venues, and Solutions"}),"\n",(0,s.jsx)(n.p,{children:"Orders will be submitted privately to Mantis on a remote procedure call (RPC)."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mantis accepts both cross-chain and single domain orders."})," Initially, Mantis will be compatible with swaps. Later, Mantis will be able to accept many order types: time-weighted average prices, bracket orders, looping, block trades, conditional trades, centralized exchange interactions, and intent-based bridging."]}),"\n",(0,s.jsxs)(n.p,{children:["Mantis can also interact with a range of protocols, from basic to complicated. The eventual goal is to facilitate any functionality, so long as it is on an IBC-connected chain (e.g. those connected by ",(0,s.jsx)(n.a,{href:"https://docs.picasso.network/",children:"Picasso"}),")."]}),"\n",(0,s.jsx)(n.p,{children:"Solutions to orders can be a combination of any of the following settlement/execution pathways:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://docs.cow.fi/cow-protocol/concepts/how-it-works/coincidence-of-wants#:~:text=CoW%20%28Coincidence%20of%20Wants%29%3A,re%20trading%20the%20same%20assets.",children:(0,s.jsx)(n.strong,{children:"Coincidence of Wants (CoWs)"})}),(0,s.jsx)(n.strong,{children:":"})," CoWs allows intents to be matched with each other. This can be done on the same chain or even cross-chain. This eliminates the need for a third party intermediary in the exchange, as user funds can be directly swapped. This further eliminates any fees or delays associated with an intermediary actor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Routes:"})," This solution path involves routing through constant function market makers (CFMMs), which are a subset of automated market makers (AMMs). CFMMs in DeFi have vast liquidity that solvers on Mantis can use to settle user intents."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Requests for Quote (RFQ):"})," Solvers request quotes from sellers for settling a user intent. RFQs prioritizes the transaction initiator\u2019s best interests via a competition of other actors trying to fulfill the other side of their trade."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Market makers\u2019 own liquidity:"})," Solvers can provide funds themselves to settle a transaction. It is possible that solvers also collaborate to combine their own liquidity to fulfill any given intent."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.p,{children:"This section outlines the syntax and structure of various data types used in Mantis. It focuses on the structures related to swap transfers, lending, and borrowing operations. It further includes explanations of the primary data structures and enums used to handle these operations. A special emphasis is put on the IntentInfo struct. The IntentInfo struct is particularly important as it consolidates the information needed for processing these operations. The LendInput, LendOutput, BorrowInput, and BorrowOutput structs are placeholders for future implementation."}),"\n",(0,s.jsx)(n.h3,{id:"data-structures",children:"Data Structures"}),"\n",(0,s.jsx)(n.h4,{id:"swaptransferinput",children:"SwapTransferInput"}),"\n",(0,s.jsx)(n.p,{children:"This represents the input data for a swap transfer operation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"struct SwapTransferInput {\n\ntoken_in: String,\n\namount_in: String,\n\nsrc_chain_user: String,\n\ntimeout: String,\n\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"token_in"}),": The token being swapped in."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"amount_in"}),": The amount of the token being swapped in."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"src_chain_user"}),": The user initiating the swap on the source chain."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"timeout"}),": The timeout duration for the swap."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"swaptransferoutput",children:"SwapTransferOutput"}),"\n",(0,s.jsx)(n.p,{children:"This represents the output data for a swap transfer operation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"struct SwapTransferOutput {\n\ntoken_out: String,\n\namount_out: String,\n\ndst_chain_user: String,\n\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"token_out"}),": The token being received in the swap."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"amount_out"}),": The amount of the token being received."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"dst_chain_user"}),": The user receiving the token on the destination chain."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"lendinput-and-lendoutput",children:"LendInput and LendOutput"}),"\n",(0,s.jsx)(n.p,{children:"These structs represent the input and output data for a lending operation. They are currently marked as TODO."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"struct LendInput {\n\n// TODO\n\n}\n\nstruct LendOutput {\n\n// TODO\n\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"borrowinput-and-borrowoutput",children:"BorrowInput and BorrowOutput"}),"\n",(0,s.jsx)(n.p,{children:"These structs represent the input and output data for a borrowing operation. They are currently marked as TODO."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"struct BorrowInput {\n\n// TODO\n\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"struct BorrowOutput {\n\n// TODO\n\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"enums",children:"Enums"}),"\n",(0,s.jsx)(n.h4,{id:"operationinput",children:"OperationInput"}),"\n",(0,s.jsx)(n.p,{children:"This encapsulates the different types of operation inputs."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"enum OperationInput {\n\nSwapTransfer(SwapTransferInput),\n\nLend(LendInput),\n\nBorrow(BorrowInput),\n\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SwapTransfer"}),": Holds a SwapTransferInput."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lend"}),": Holds a LendInput."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Borrow"}),": Holds a BorrowInput."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"operationoutput",children:"OperationOutput"}),"\n",(0,s.jsx)(n.p,{children:"This encapsulates the different types of operation outputs."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"enum OperationOutput {\n\nSwapTransfer(SwapTransferOutput),\n\nLend(LendOutput),\n\nBorrow(BorrowOutput),\n\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SwapTransfer"}),": Holds a SwapTransferOutput."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lend"}),": Holds a LendOutput."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Borrow"}),": Holds a BorrowOutput."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"intentinfo",children:"IntentInfo"}),"\n",(0,s.jsx)(n.p,{children:"This struct encapsulates the overall intent information for an operation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"struct IntentInfo {\n\nfunction_name: String,\n\nsrc_chain: String,\n\ndst_chain: String,\n\ninputs: OperationInput,\n\noutputs: OperationOutput,\n\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"function_name"}),": The name of the function being called."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"src_chain"}),": The source blockchain for the operation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"dst_chain"}),": The destination blockchain for the operation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"inputs"}),": The inputs for the operation, represented by OperationInput."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"outputs"}),": The outputs for the operation, represented by OperationOutput."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"summary-diagram",children:"Summary Diagram"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"summary",src:t(5905).A+"",width:"1427",height:"772"})}),"\n",(0,s.jsxs)(n.h2,{id:"solver-algorithm",children:["Solver Algorithm",(0,s.jsx)(n.a,{href:"https://docs.composable.finance/technology/mantis/solvers-solutions#solver-algorithm",children:"\u200b"})]}),"\n",(0,s.jsx)(n.p,{children:"On Mantis, solvers need to come up with the best routes for users\u2019 intents. This involves determining the best price. An algorithm is used by solvers to determine such optimal solution routes."}),"\n",(0,s.jsxs)(n.p,{children:["An example Mantis solver algorithm can be viewed ",(0,s.jsx)(n.a,{href:"https://github.com/ComposableFi/cvm/tree/main/mantis/node/src/solver",children:"here"}),". The mathematical process with which we generated and tested this algorithm is detailed in ",(0,s.jsx)(n.a,{href:"https://github.com/ComposableFi/composable-vm/blob/44f02baf990c16b003a51a85a50a97a1d24e7c1e/Cross-Domain-COWs-%26-Constant-Function-MM-Routing.pdf",children:"this paper by Composable and Bruno Mazorra."})]}),"\n",(0,s.jsx)(n.h3,{id:"fast-withdrawals",children:"Fast Withdrawals"}),"\n",(0,s.jsx)(n.p,{children:"We are implementing an architecture that allows fast withdrawals from swaps along our IBC-connected infrastructure. Users will be able to indicate they would like to participate in fast withdrawal as a part of their intent specifications. Initially, fast withdrawals will only be supported for limit orders."}),"\n",(0,s.jsx)(n.p,{children:"A contract on both sides (i.e. both the source chain and the destination chain) allows the user to get their funds from the market maker quickly. A USDT pool on both sides of the transaction enables USDT to be quickly transferred in this manner. The market maker will be able to tap into an endpoint for rebalancing. The market maker can swap out of this pool."}),"\n",(0,s.jsx)(n.p,{children:"This works as follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"A user submits an intent and opts for fast withdrawal. Market makers listen to new intents being broadcast to the Mantis smart contract (which communicates with the Picasso IBC bridge)."}),"\n",(0,s.jsx)(n.li,{children:"Market makers distribute USDT to the user through the Mantis smart contract."}),"\n",(0,s.jsx)(n.li,{children:"The market maker asks the smart contract to be sure these tokens were sent to the user. The smart contract on the destination chain sends a cross-chain message indicating this to a smart contract on the destination chain."}),"\n",(0,s.jsx)(n.li,{children:"A cross-chain message is sent allowing the market maker to claim the USDT from an intent."}),"\n",(0,s.jsx)(n.li,{children:"The market maker claims the USDT tokens."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This is shown below, with the numbers representing the corresponding steps above:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"fast",src:t(9145).A+"",width:"1600",height:"484"})}),"\n",(0,s.jsx)(n.h2,{id:"scoring",children:"Scoring"}),"\n",(0,s.jsx)(n.h1,{id:"failure",children:"Failure"}),"\n",(0,s.jsx)(n.p,{children:"[add what happens in the event of txn failure - TBD]"}),"\n",(0,s.jsx)(n.h2,{id:"conditional-intents",children:"Conditional Intents"}),"\n",(0,s.jsx)(n.p,{children:"While intents in decentralized finance (DeFi) are often described as a broad concept, current intent-based applications typically focus on a limited set of intent types. These commonly take the form of limit orders or bridge transactions, such as:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'"Trade asset A for asset B with a minimum price p"'}),"\n",(0,s.jsx)(n.li,{children:'"Transfer asset A to domain Z"'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"However, the theoretical potential of intents extends far beyond these basic use cases. Ideally, intents should serve as a tool allowing agents to express \"arbitrary\" preferences over state transitions within a single domain or across multiple domains.\nIn economic literature, limit price-type intents can be conceptualized as expressions of an agent's private valuations over assets. Private valuations refer to the subjective worth an individual assigns to an asset, independent of others' opinions or market conditions. For instance, an individual might value a rare coin based on personal interest or sentimental attachment, regardless of its market price (also known as Walrasian demands)."}),"\n",(0,s.jsx)(n.p,{children:"However, it's crucial to recognize that users and agents often do not operate solely on private valuations. In reality, economic actors are interdependent, and their valuations of certain objects can depend significantly on the valuations of others. A prime example of this phenomenon is the valuation of digital art."}),"\n",(0,s.jsx)(n.p,{children:"In such cases, if no one expresses any valuation for an item, people generally wouldn't value it. Conversely, when an item experiences high demand, agents often interpret this demand as a positive signal, indicating that the item possesses some intrinsic value. This concept aligns with the greater fool theory and speculative bubbles in financial markets."}),"\n",(0,s.jsx)(n.p,{children:"Given this reality, intents should be capable of capturing these interdependent valuations. Many items are not valued in isolation from the world (unlike, for example, consuming an apple, which is generally independent of others' consumption). Instead, their value is deeply intertwined with other agents' valuations."}),"\n",(0,s.jsx)(n.p,{children:"Natural examples of interdependent valuations that could be expressed through more sophisticated intents include:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Stop-losses: An order to sell an asset when it reaches a certain price, reflecting a valuation dependent on market movements."}),"\n",(0,s.jsx)(n.li,{children:"Bidding in NFT auctions: Where the perceived value of an NFT can be influenced by the bids of other participants."}),"\n",(0,s.jsx)(n.li,{children:"Copy-trading strategies: Where an agent's trading decisions are based on the actions of another trader (use other traders actions as positive or negative signals)."}),"\n",(0,s.jsx)(n.li,{children:"Dynamic liquidity provision: Adjusting liquidity based on market volatility or trading volume."}),"\n",(0,s.jsx)(n.li,{children:"Trading conditional to prediction market quotes on real events."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By expanding the concept of intents to encompass these interdependent valuations, DeFi protocols and users can more accurately reflect the complex decision-making processes of market participants. This evolution could lead to more efficient markets, improved price discovery mechanisms, and a closer alignment between DeFi systems and real-world economic behaviors. We call this subset of intents conditional intents, emphasizing that the execution of such is conditioned to external signals or events."}),"\n",(0,s.jsx)(n.p,{children:"Because intents on Mantis are generalized, artificial intelligence (AI) agents will be capable of submitting time-based conditional intents through the protocol. For example, a user may want to make a particular swap at the best price within the next 48 hours. They provide this information to the AI agent, which makes a prediction about when the best price will be within this time constraint. Then, at this time, the AI agent submits an intent to carry out the swap to Mantis. This abstracts conditionality away from solvers and puts it in the hands of AI agents who likely have more powerful algorithms to determine the best timing of swaps. Then, solvers are left to handle identification and execution of the best transaction route at that time. In this manner, the strengths and optimizations of the Mantis protocol and of AI agents are able to synergize, providing the best execution."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},9145:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/fast-bridge-1af08244fad86cb605e6e6a5bb37b7c1.png"},5905:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/summary-4e66a0ddc20dc5ed7f196671f81fee61.png"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);